
2.  64位编译32bit　as
    将　32寄存器　换成　６4　　　movl -> movq  pushl pushq
    %h传递参数　　64  rdi rsi rdx rcx r8 r9
    movq	$buffer, %rsi
    movq	$output, %rdi

     as -o bcpuid.o bcpuid.s
     ld  -dynamic-linker /lib/ld-linux-x86-64.so.2 -o bcpuid  -lc  bcpuid.o

    使用ｃ函数时，注意参数　％ｓ
 
    使用gcc -m32

3. 编译32bit
    代码加入 .code32
    as --32 -o bcpuid.o bcpuid.s
    ld -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o bcpuid  -lc  bcpuid.o

    as --32 -o bcpuid.o bcpuid.s
    ld -m elf_i386  /lib/ld-linux.so.2 -o bcpuid   bcpuid.o

4. 64位调用约定与函数传参
x86:
push eax
call xxx

xxx fun proc

push        ebp          保存栈底
mov         ebp,esp      设置ebp
sub         esp,0C0h     开辟局部变量空间
push        ebx          保存寄存器环境
push        esi  
push        edi  

pop         edi          恢复寄存器环境
pop         esi  
pop         ebx          
mov         esp,ebp      释放局部变量空间
pop         ebp          恢复栈底
ret                      返回,平展, 如果是 C在外平展 add esp,xxx stdcall 则内部平展 ret 4      


x64:
AT&T　　RDI, RSI, RDX, RCX, R8, R9
sub rsp,0x28

mov r9,1
mov r8,2
mov rdx,3
mov rcx,4
call xxx
add rsp,0x28
(1)传参方式
首先说明一下,在X64下,是寄存器传参. 前4个参数分别是 
 rcx rdx r8 r9进行传参.多余的通过栈传参.从右向左入栈.
( )申请参数预留空间
在x64下,在调用一个函数的时候,会申请一个参数预留空间.用来保存我们的参数.比如以前我们通过push压栈
参数的值.相应的栈就会抬高.其实x64下,一样会申请.只不过这个地方在进函数的时候并没有值.
进入函数之后才会将寄存器的值在拷贝到这个栈中.
 其实就相当于你还是push了.只不过我是外边申请空间,内部进行赋值.

 5. 探索64a传递参数


6 char    ASCII    x
   0       48      0x30
   A       65      0x41  
   a       96      0x61

7 命令行参数　x86_32
　进入程序后，%es所指的位置即为　argc
  esp+4为第一个命令行参数（指针）
     +8  第二个
     ．．．
命令行参数最后一个下面，是0x00
然后开始是环境变量
--------------------　　　　　　　　　　　　　
环境变量　         　｜　　　　　　　　　　　＃高地址
--------------------
0x00    　         ｜
--------------------
第三个命令行参数　　　｜
--------------------
第二个命令行参数　　　｜
--------------------
第一个命令行参数　　　｜
--------------------
argc          　　　｜   <-----  (%esp) #低地址
--------------------

8 调用函数栈帧
-------|---------|--------|
地址    |  内容   |  介绍   |
-------|---------|--------|
0xc90  |   6     | 参数６　|
-------|---------|--------|
0xc94  |   5     | 参数5　|
-------|---------|--------|
0xc98  |   4     | 参数4　|
-------|---------|--------|
0xc9c  |   3     | 参数3　|
-------|---------|--------|
0xca0  |   2     | 参数2　|
-------|---------|--------|
0xca4  |   1     | 参数1　|
-------|---------|--------|
0xca8  | 0xffdcd6|　不知道
-------|---------|--------|
0xcb0  |    7    | 局部变量|
-------|---------|--------|
0xcb4  |  8      | 局部变量|
-------|---------|--------|
0xcb8  |    9    | 局部变量|
-------|---------|--------|
0xcbc  |   a     | 局部变量|
-------|---------|--------|
0xcc0  |   b     | 局部变量|
-------|---------|--------|
0xcc4  |    0    | 对齐填充|
-------|---------|--------|
0xcc8  |  0xdd0  |存%rsp 　|
-------|---------|--------|
0xcd0  |0x5555160|函数返回地址|
-------|---------|--------|
0xcd8  |     7   |参数７ 　|
---------------------------

8.数据传递
 movs
 cmps
 scas
 lods
 stos

 req
 repe/repz
 repne/repnz

隐含操作数
    源串地址　DS:SI,目的串 ES:DI,长度cx
处理后的操作
    修改si di,指向下一个串元素
    若用rep, cx自动-1
方向
DF=0,低地址开始, CLD
DF=1,        , STD